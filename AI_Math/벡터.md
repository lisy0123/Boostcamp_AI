# 백터

숫자를 원소로 가지는 리스트(list) 또는 배열(array)

```python
x = [1, 7, 2]
x = np.array([1,7,2])
```

<<img src="https://user-images.githubusercontent.com/60209937/128105625-1f3dbcea-b74e-4b39-b194-e143074adba2.png" alt="image1" style="zoom:50%;" />

- 벡터는 공간에서 **한 점**을 나타냄

- 백터는 원점으로부터 상대적 위치 표현

- 숫자를 곱하면 길이만 변한다.

$\alpha x = \begin{bmatrix}\alpha x_1\\\alpha x_2\\\alpha x_3\end{bmatrix}$​

$\alpha$: 스칼라곱

>  $\alpha x_1 > 1$​ => 길이 늘어남
>
> $\alpha x_1 < 1$ => 길이 줄어듬
>
> $\alpha x_1 < 0$ => 반대 방향

- 같은 모양을 가지면 덧셈, 뺄셈을 계산할 수 있다.

- 같은 모양을 가지면 성분곱(Hadamard product) 계산 가능

$x = \begin{bmatrix}x_1\\x_2\\\vdots\\x_d\end{bmatrix}, y = \begin{bmatrix}y_1\\y_2\\\vdots\\y_d\end{bmatrix}, x\odot y = \begin{bmatrix}x_1y_1\\x_2y_2\\\vdots\\x_dy_d\end{bmatrix}$​

- 두 벡터의 덧셈: 다른 백터로부터 상대적 위치이동 표현

  <img src="https://user-images.githubusercontent.com/60209937/128105628-459d1429-2ab9-4f08-be56-fca56d72733d.png" alt="image2" style="zoom:50%;" />

  <img src="https://user-images.githubusercontent.com/60209937/128105631-7ca909a5-4771-4783-92df-465615956080.png" alt="image3" style="zoom:50%;" />

  <img src="https://user-images.githubusercontent.com/60209937/128105811-65c65802-5594-428e-bf2e-f4f371fe0646.png" alt="image3" style="zoom:50%;" />

- 백터의 **노름(norm)**: 원점에서부터의 거리

  - $L_1$​​-노름: 각 성분의 변화량의 절대값을 모두 더함 => 맨하튼 노름

    ![image5](https://user-images.githubusercontent.com/60209937/128105813-029c55c8-827b-4803-8cbb-0c51880c4bf2.png)

  - $L_2$​​-노름: 피타고라스 정리를 이용해 유클리드 거리 계산 => 유클리드 노름

![image6](https://user-images.githubusercontent.com/60209937/128105814-1c4a9811-3f9d-4a51-ba6d-83fe1dcce6cb.png)

```python
def l1_norm(x):
  x_norm = np.abs(x)
  x_norm = np.sum(x_norm)
  return x_norm

def l2_norm(x):
  x_norm = x*x
  x_norm = np.sum(x_norm)
  x_norm = np.sqrt(x_norm)
  return x_norm

# L2 노름은 np.linalg.norm을 이용해도 구현 가능
```

- 노름의 종류에 따라 기하학적 성질 달라진다.

  <img src="https://user-images.githubusercontent.com/60209937/128105817-3d8e8f0a-f79c-43e9-8815-e4c7b601cd4d.png" alt="image7" style="zoom:60%;" />

- 두 벡터 사이의 거리 계산 => 벡터 뺄셈 이용

  <img src="https://user-images.githubusercontent.com/60209937/128105818-fc114589-b8da-4884-a063-fdb30d60bc20.png" alt="image8" style="zoom:50%;" />

- 두 벡터 사이의 거리 이용하여 각도 계산 **($L_2$​​-노름인 $\begin{Vmatrix}\dots\end{Vmatrix}_2$​​​​​만 가능하다)**

  제2 코사인 법칙에 의해 두 벡터 사이의 각도 계산할 수 있다.

  분자를 쉽게 계산하는 방법이 내적(inner product)

  <img src="https://user-images.githubusercontent.com/60209937/128105819-467046c0-78fb-49cb-b1d7-ea075a9e0485.png" alt="image9" style="zoom:50%;" />

  <img src="https://user-images.githubusercontent.com/60209937/128105820-40b79942-71fc-450d-8b57-5b6085ce9505.png" alt="image10" style="zoom:50%;" />

- 내적: 정사영(orthogonal projection)된 벡터의 길이와 관련

- 내적: $ <x, y> = \Vert x\Vert_2 \Vert y\Vert_2 \cos(\theta)$

  <img src="https://user-images.githubusercontent.com/60209937/128105821-a5d0403c-d3b5-407e-b7cd-9f1fbc2cce44.png" alt="image11" style="zoom:70%;" />

- Proj(x)의 길이는 코사인법칙에 의해 $\begin{Vmatrix}x\end{Vmatrix}cos\theta$ 가 된다.

  <img src="https://user-images.githubusercontent.com/60209937/128105822-eebf449d-294b-4b19-82ef-8b4b7e86e354.png" alt="image12" style="zoom:70%;" />

- 내적은 정사영의 길이를 백터 y의 길이 $\begin{Vmatrix}y\end{Vmatrix}$​만큼 조정한 값

  <img src="https://user-images.githubusercontent.com/60209937/128105823-a67af7d4-2eb7-41e1-af1f-1e7a7ad08f8a.png" alt="image13" style="zoom:70%;" />

